---
layout: default
group: extension-dev-guide
subgroup: 99_Module Development
title: Indexer optimization
menu_title: Indexer optimization
menu_order: 14
version: 2.2
level3_menu_node: level3child
level3_subgroup: index
github_link: extension-dev-guide/indexer-batch.md

---

## Indexer Batching

Magento can increase the memory for processing a large amount of data by using memory engines instead of InnoDB. The algorithm increases the memory value for the `max_heap_table_size` and `tmp_table_size` MySQL parameters.

<div class="bs-callout bs-callout-info" id="info" markdown="1">
When the allocated memory size for a temporary table will be greater than 20% of `innodb_buffer_pool_size`, the following message is written to the Magento log.

`Memory size allocated for the temporary table is more than 20% of innodb_buffer_pool_size.`

To prevent this error message, update `innodb_buffer_pool_size` or decrease the batch size value (which decreases memory usages for the temporary table).
</div>

The interface `BatchSizeManagementInterface` provides the ability to set the MEMORY table size for indexer processes according to batch size and index row size.

{% highlight php %}
namespace Magento\Framework\Indexer;

use \Magento\Framework\DB\Adapter\AdapterInterface;

/**
 * Batch size manager can be used to ensure that MEMORY table has enough memory for data in batch.
 * @api
 */
interface BatchSizeManagementInterface
{
    /**
     * Ensure memory size for data in batch.
     *
     * @param AdapterInterface $adapter database adapter.
     * @param int $batchSize
     * @return void
     */
    public function ensureBatchSize(\Magento\Framework\DB\Adapter\AdapterInterface $adapter, $batchSize);
}
{% endhighlight %}


The interface `IndexTableRowSizeEstimatorInterface` calculates the memory size for all rows per entity in the index table.. The entity can store several rows in an index table generated by different store dimensions, such as count of websites and customer groups.

{% highlight php %}
namespace Magento\Framework\Indexer;

/**
 * Calculate memory size for entity according different dimensions.
 * @api
 */
interface IndexTableRowSizeEstimatorInterface
{
    /**
     * Calculate memory size for entity row.
     *
     * @return float
     */
    public function estimateRowSize();
}
{% endhighlight %}


## Batching configuration

Batching is available for the following indexers:

Index name | Configuration file | Configured object | Parameter name | Default value
--- | --- | --- | --- | ---
catalog_product_price (Product Price)	| `Magento/Catalog/etc/di.xml` | `Magento\Catalog\Model\ResourceModel\Product\Indexer\Price\BatchSizeCalculator` | batchRowsCount['default']	| 5000
cataloginventory_stock (Stock)	| `Magento/CatalogInventory/etc/di.xml`	| `Magento\CatalogInventory\Model\Indexer\Stock\Action\Full` | batchRowsCount['default']	| 200
catalog_category_product (Category Products)| `Magento/Catalog/etc/di.xml`	| `Magento\Catalog\Model\Indexer\Category\Product\Action\Full` |	batchRowsCount	| 100000

The following examples illustrate how to define a custom batch size for configurable products. Add these samples to your  `{Your_Module_Name}/etc/di.xml`.

{% highlight xml %}
....
<type name="Magento\Catalog\Model\ResourceModel\Product\Indexer\Price\BatchSizeCalculator">
    <arguments>
        <argument name="batchRowsCount" xsi:type="array">
            <item name="configurable" xsi:type="number">5000</item>
        </argument>
    </arguments>
</type>
...
{% endhighlight %}

{% highlight xml %}
<type name="Magento\CatalogInventory\Model\Indexer\Stock\Action\Full">
    <arguments>
        <argument name="batchRowsCount" xsi:type="array">
            <item name="configurable" xsi:type="number">200</item>
        </argument>
    </arguments>
</type>
{% endhighlight %}

## Indexer Table Switching

Magento optimizes certain indexer processes to prevent deadlocks and wait locks caused by read/write collisions on the same table. In these cases, Magento uses separate tables for performing read operations and reindexing. As a result of this table switching process, customers are not impacted when you run a full reindex. For example, when `catalog_product_price` is reindexing, customers won't be slowed down as they navigate on Categories pages, search products, or user layer navigation filters with price filters.

Magento uses the following tables to support table switching.

Indexer name | Tables used
--- | --- | ---
`catalog_product_price`	|  `catalog_product_index_price`, `catalog_product_index_price_replica`
`cataloginventory_stock` | `cataloginventory_stock_status`, `cataloginventory_stock_status_replica`
`catalog_category_product` | `catalog_category_product_index`, `catalog_category_product_index_replica`
`catalog_product_attribute` (select, multiselect attributes) | `catalog_product_index_eav`, `catalog_product_index_eav_replica`
`catalog_product_attribute` (decimal values) |`catalog_product_index_eav_decimal`, `catalog_product_index_eav_decimal_replica`

The value of `table_suffix` column of the `indexer_state` table determines which table is used for read operations (which include partial reindexes, frontend calls, and searching by attributes), and which table is used for full reindexes. Initially, the value of`table_suffix` is an empty string. As an example, for indexer `catalog_product_prices`, this means Magento uses `catalog_product_index_price` for _read operations_ and `catalog_product_index_price_replica` for _full reindexes_. Once the reindex is complete, the value of `table_suffix` is changed to `_replica` and Magento uses `catalog_product_index_price_replica` for _read operations_ and `catalog_product_index_price` for _full reindexes_. The value of  `table_suffix` is changed to an empty string, and the cycle repeats.

Make sure that these indexers are in "Update By Schedule" mode. If "Update On Save" mode is selected, some data can be lost if you make changes during full reindex.

<div class="bs-callout bs-callout-info" id="info" markdown="1">
Indexer table switching mechanism requires additional database storage.
</div>
